# **Randomized Row-Swap (RRS) 논문 분석**

## 📌 1. 개요 (Introduction)
본 문서는 **"Randomized Row-Swap (RRS)"** 논문을 분석한 내용을 정리한 것입니다.  
논문에서 제안한 **RRS 기법의 동작 방식, 보안성, 성능 분석, 기존 방어 기법과의 비교, 최신 DRAM 아키텍처에서의 적용 가능성** 등을 심층적으로 분석하였습니다.

---

## **📌 2. RRS 논문의 주요 기여 (Key Contributions)**
논문에서 제안한 **RRS(Randomized Row-Swap)** 기법은 Row Hammer 공격을 방어하는 새로운 접근 방식으로, 기존 기술과 차별화되는 주요 특징을 가집니다.

### **✅ RRS의 핵심 기여**
1️⃣ **Row Hammer 공격 완화:**  
   - 공격자가 특정 행(Aggressor Row)을 Hammering하여 인접한 행(Victim Row)에 비트 플립(Bit-Flip)을 유발하는 것을 방지  
   - **Aggressor Row를 무작위(Random)로 다른 행과 Swap(교체)하여 공격자의 타겟팅을 어렵게 만듦**  
   
2️⃣ **기존 방어 기법과의 차별성:**  
   - 기존의 **Victim-Focused Mitigation** (피해 행을 보호하는 기법)과 달리, **Aggressor Row 자체를 바꿔버리는 새로운 방식**을 제안  
   - ECC, Software-Only Solutions, Per-Bank Refresh 등 기존 기법보다 **더 적은 성능 오버헤드**를 가짐  

3️⃣ **낮은 성능 오버헤드:**  
   - 기존의 ECC 및 Software-Only Solutions 대비 **낮은 성능 저하(약 0.4%)를 보이며, 실용적인 방어 기법으로 적용 가능**  

4️⃣ **추가적인 DRAM 매핑 정보 불필요:**  
   - 기존의 Row Hammer 방어 기법은 **DRAM 내부의 특정 행 매핑 정보를 필요로 하지만**, RRS는 이를 필요로 하지 않음  
   - **따라서, 다양한 DRAM 아키텍처에 적용 가능함**  

---

## **📌 3. RRS의 개념 및 동작 방식**
### **🔹 3.1 RRS의 기본 개념**
✔ **RRS는 특정 Row가 일정 횟수 이상(Threshold) 활성화되면, 해당 Row를 무작위(Random)로 다른 Row와 Swap하는 방식으로 Row Hammer 공격을 방어함.**  
✔ **이 방식은 공격자가 특정 Row를 반복적으로 Hammering하여 비트 플립(Bit-Flip)을 유도하는 전략을 무력화함.**  

---

### **🔹 3.2 RRS의 주요 구성 요소**
RRS는 다음과 같은 주요 구성 요소로 이루어져 있습니다.

| **구성 요소** | **설명** |
|-------------|---------|
| **Hot-Row Tracker** | 일정 횟수 이상 활성화된 Row를 감지하는 기능 |
| **Row Indirection Table (RIT)** | 특정 행을 Swap할 때, 원래의 행과 새로운 행 간의 매핑 정보를 저장 |
| **Swap-Buffer** | Swap이 발생할 때, 일시적으로 데이터를 저장하여 성능 오버헤드를 줄임 |

---

## **📌 4. 기존 방어 기법과의 비교**
기존의 Row Hammer 방어 기법들은 다음과 같은 방식으로 작동합니다.

| **방어 기법** | **핵심 원리** | **RRS와의 차이점** |
|-------------|-------------|-------------|
| **ECC-Based Defenses** | 오류 정정 코드(ECC)를 활용하여 Bit-Flip을 감지 및 수정 | RRS는 ECC 없이도 공격을 방어 가능 |
| **Victim-Focused Mitigation (VFM)** | 피해 행(Victim Row)을 주기적으로 Refresh하여 보호 | RRS는 피해 행이 아닌 공격 행(Aggressor Row)을 Swap |
| **Software-Only Defenses** | 소프트웨어 기반 감지 및 방어 (예: ANVIL, GuardION) | RRS는 하드웨어 레벨에서 직접 방어 |
| **DDR5의 Fine-Grained Refresh** | 특정 Row만 선택적으로 Refresh하여 공격 방어 | RRS는 Swap 방식을 사용하여 더 적극적으로 공격 차단 |

---

## **📌 5. RRS의 한계점 (Limitations)**
### **🔹 최신 DRAM 아키텍처(DDR5, LPDDR5)에서의 한계점**
✅ **Swap Overhead 문제:**  
   - DDR5 및 LPDDR5는 높은 대역폭(Bandwidth)과 병렬성을 제공하지만, **Row-Swap 연산은 추가적인 데이터 이동 비용을 발생시킬 가능성이 큼.**  
   - **Swap이 잦아지면 DRAM 성능이 저하될 가능성이 있으며, 최신 DRAM의 Refresh 스케줄과 충돌할 수 있음.**  

✅ **전력 효율 문제:**  
   - LPDDR5와 같은 저전력 DRAM에서는 **Swap 연산이 추가적인 전력 소비를 유발할 가능성이 높음.**  
   - 특히, **Deep Power-Down Mode와 같은 전력 절감 기능과 충돌할 가능성이 있음.**  

✅ **Bank-Aware Swap 필요성:**  
   - DDR5에서는 **Bank Group 구조를 사용하여 Swap이 특정 Bank 내에서만 이루어지도록 제한될 가능성이 있음.**  
   - 즉, **Swap이 Bank 간에 이루어지지 않으면 공격자가 특정 Bank를 집중적으로 Hammering할 수 있는 취약점이 발생할 수 있음.**  

---

### **🔹 기존 DRAM(DDR3, DDR4)에서의 한계점**
✅ **Swap 시 성능 저하 문제:**  
   - 기존 DRAM에서는 **Row-Swap이 추가적인 메모리 액세스를 유발하여 전체적인 성능이 저하될 가능성이 있음.**  
   - 특히, CPU와 DRAM 간의 메모리 액세스 병목(Bandwidth Bottleneck)이 더욱 심해질 수 있음.  

✅ **Predictable Swap Pattern 위험:**  
   - 공격자가 Swap 패턴을 분석하여 Row Hammer 공격을 변형할 가능성이 있음.  
   - 즉, **RRS가 무작위(Random)로 Swap을 수행하더라도, 일정한 패턴을 가진다면 공격자가 이를 우회할 가능성이 존재.**  

---

## **📌 6. RRS 개선 방향 (Future Work)**
1️⃣ **Adaptive Row-Swap 적용:** Swap을 무작위(Random)로 수행하는 것이 아니라, **공격 패턴을 실시간으로 분석하여 Swap 빈도를 최적화**  
2️⃣ **Bank-Aware Swap 설계:** 특정 Bank 내에서만 Swap이 수행되지 않도록, **Bank 간 Swap을 허용하는 방식 고려**  
3️⃣ **Low-Power Swap 기법 적용:** **Row Clone, In-DRAM Copy 등 최신 기술 활용**하여 Swap의 전력 소모를 줄이는 방식 적용  

---


# **4. Randomized Row-Swap (RRS) 분석**

## **📌 4.1 Overview of RRS**
### **✅ 개요**
✔ RRS(Randomized Row-Swap)는 **Row Hammer(RH) 공격을 방어하기 위한 새로운 기법**으로, **Aggressor Row를 무작위(Random)로 다른 Row와 Swap(교체)하는 방식**을 사용함.  
✔ 이를 통해 공격자가 특정 Row를 반복적으로 Hammering하여 **Victim Row에 Bit-Flip을 유발하는 것을 방지할 수 있음.**  

---

### **✅ RRS의 핵심 아이디어**
- 기존의 Row Hammer 방어 기법은 **피해 행(Victim Row)을 보호하는 방식**이었음.  
- 하지만, **RRS는 공격 행(Aggressor Row) 자체를 바꿔버리는 새로운 방식**을 적용하여 공격자의 타겟팅을 무력화함.  
- **즉, 특정 Row가 활성화(Access)되는 빈도를 추적하고, 일정 임계값(Threshold)을 초과하면 해당 Row를 무작위(Random)로 다른 Row와 Swap하는 방식.**  

---

## **📌 4.2 Hot-Row Tracker**
### **✅ 역할**
✔ **Hot-Row Tracker는 특정 행(Row)이 너무 자주 활성화되는지 감지하는 모듈**  
✔ **활성화 횟수가 특정 임계값(Threshold, T)에 도달하면, Swap이 필요함을 결정**  

### **✅ 동작 방식**
1️⃣ **각 행(Row)에 대해 활성화 횟수를 모니터링**  
2️⃣ **특정 Row가 임계값 T를 초과하면, Row-Swap을 수행해야 한다는 신호를 보냄**  
3️⃣ **Swap을 수행할 대상 행을 결정하는 과정에서, Randomized Row-Swap을 통해 공격자가 Swap 패턴을 예측하지 못하도록 함**  

📌 **즉, Hot-Row Tracker는 특정 Row가 너무 자주 접근되는지 감지하여 Swap을 수행할 필요가 있는지 판단하는 역할을 함.**

---

## **📌 4.3 Row Indirection Table (RIT)**
### **✅ 역할**
✔ **Swap이 발생하면, 원래 Row와 새로운 Row 간의 매핑 정보를 저장하는 데이터 구조**  
✔ **CPU 또는 DRAM 컨트롤러가 메모리에 접근할 때, RIT를 참조하여 Swap된 주소를 확인할 수 있도록 함**  

### **✅ RIT의 구조**
| **필드** | **설명** |
|---------|---------|
| **Source Row-ID** | Swap 전 원래 행의 ID |
| **Destination Row-ID** | Swap 후 변경된 행의 ID |
| **Lock-Bit** | 해당 매핑이 현재 활성 상태인지 나타내는 비트 |

### **✅ RIT의 동작 방식**
1️⃣ 특정 Row가 Swap될 필요가 있다고 판단되면, 새로운 행으로 Swap 수행  
2️⃣ 기존 Row와 새로운 Row 간의 매핑 정보를 RIT에 저장  
3️⃣ 이후 메모리 접근 시, **RIT를 참조하여 Swap된 주소를 올바르게 매핑**  

📌 **즉, RIT는 Row-Swap이 발생한 후에도 시스템이 정상적으로 동작할 수 있도록 Swap된 Row의 주소 정보를 관리하는 역할을 함.**

---

## **📌 4.4 Support for Row Swapping**
### **✅ Swap을 효율적으로 수행하는 방법**
✔ **DRAM 내부에서 Row-Swap을 수행할 때, Swap으로 인한 성능 저하를 최소화하는 것이 중요함.**  
✔ 이를 위해 **Streaming Access를 활용하여 Swap을 빠르게 수행할 수 있도록 최적화**  

### **✅ Streaming Access를 활용한 Row-Swap**
- DRAM은 **대용량 데이터를 연속적으로 읽고 쓰는 작업(Streaming Access)에 최적화됨.**  
- **Swap을 수행할 때, 단순히 데이터를 복사하는 것이 아니라 Streaming 방식으로 Swap을 수행하면 오버헤드를 줄일 수 있음.**  
- 이를 통해 **Row-Swap이 발생하는 동안 전체적인 성능 저하를 최소화할 수 있음.**  

📌 **즉, Streaming Access 기법을 활용하면 Row-Swap의 성능을 최적화할 수 있으며, 불필요한 성능 저하를 줄이는 것이 가능함.**

---

## **📌 4.5 Optimizing Indirection Lookups**
### **✅ Indirection Lookup 최적화의 필요성**
✔ **메모리에 접근할 때마다 RIT를 조회하면 성능이 저하될 수 있음.**  
✔ 따라서, **효율적인 Lookup 메커니즘을 도입하여 성능 오버헤드를 최소화하는 것이 중요함.**  

### **✅ 최적화 기법**
1️⃣ **Caching을 활용하여 자주 사용되는 매핑 정보를 빠르게 조회할 수 있도록 함.**  
2️⃣ **Lookup 연산을 수행할 때, 기존 DRAM 구조와 호환되도록 최적화하여 추가적인 연산 부담을 줄임.**  

📌 **즉, Indirection Lookup을 최적화하면 RRS의 성능 저하 문제를 줄이고, Swap 이후에도 원활한 메모리 접근이 가능하게 할 수 있음.**

---

## **📌 4.6 Scalability Considerations**
### **✅ RRS의 확장성 문제**
✔ **RRS는 Swap을 수행할 때, 추가적인 메모리 공간 및 연산이 필요함.**  
✔ 따라서, **DRAM의 대역폭(Bandwidth) 및 성능 저하를 최소화하는 방향으로 설계를 최적화해야 함.**  

### **✅ 해결책**
1️⃣ **하드웨어 지원을 통해 Swap 연산을 최적화하여 성능 저하를 줄이는 방법 고려.**  
2️⃣ **RIT 및 Hot-Row Tracker의 메모리 공간을 최소화하여 추가적인 오버헤드를 방지.**  
3️⃣ **Swap이 발생하는 빈도를 줄이기 위해, Adaptive Swap 전략을 도입하는 방안 고려.**  

📌 **즉, 확장성을 고려하여 RRS의 설계를 최적화하면, 최신 DRAM 환경에서도 효과적으로 적용할 수 있음.**

---

## **📌 4.7 Summary of RRS**
✔ **RRS는 Row Hammer 공격을 방어하기 위한 효과적인 방법이며, 기존의 Victim-Focused Mitigation 방식과 차별화됨.**  
✔ **Hot-Row Tracker를 활용하여 특정 행이 과도하게 활성화되는지 감지하고, 필요할 때 Swap을 수행함.**  
✔ **Row Indirection Table (RIT)을 사용하여 Swap 이후에도 메모리 접근을 원활하게 유지할 수 있음.**  
✔ **Streaming Access 기법을 활용하여 Swap 성능을 최적화하고, Indirection Lookup을 효율적으로 수행함.**  
✔ **Swap 연산이 발생하는 동안 DRAM 성능 저하를 최소화하기 위해 최적화가 필요하며, 확장성 문제를 해결하기 위한 개선 방안이 필요함.**

---

📌 **즉, 4. Randomized Row-Swap (RRS) 섹션은 RRS의 핵심 동작 방식과 최적화 방안에 대해 설명하며, 이를 통해 기존의 Row Hammer 방어 기법보다 더 효율적인 보호 기법을 제안함.** 🚀

---

# **5. Security Analysis (보안 분석)**

## **📌 5.1 Assumptions (가정)**
### **✅ RRS가 가정하는 보안 모델**
RRS는 Row Hammer 공격을 방어하기 위해 몇 가지 가정을 기반으로 설계됨.

1️⃣ **공격자는 DRAM의 특정 행(Row)을 반복적으로 Hammering할 수 있음.**  
   - 이는 기존의 Row Hammer 공격과 동일한 가정임.  
   - 공격자는 특정 Aggressor Row를 반복적으로 활성화(Activation)하여 인접한 Victim Row에 비트 플립(Bit-Flip)을 유발하려고 시도함.

2️⃣ **RRS는 공격자의 행위(Access Pattern)를 완전히 숨기지는 않음.**  
   - 공격자가 특정 행을 반복적으로 Hammering할 수 있다는 가정하에, RRS는 이를 완전히 숨기는 것이 아니라 **Swap을 통해 방어하는 방식**을 사용함.

3️⃣ **Swap이 이루어질 때, 새로운 행의 위치는 공격자가 예측할 수 없어야 함.**  
   - 공격자가 특정한 Row를 Hammering하면, 해당 Row는 무작위(Random)로 다른 Row와 Swap됨.  
   - 이를 통해 공격자가 특정한 Victim Row를 찾는 것이 어렵게 됨.

📌 **즉, RRS는 공격자가 특정 행을 Hammering할 수 있다는 가정을 하며, Swap을 통해 Row Hammer 공격을 방어하는 전략을 사용함.**

---

## **📌 5.2 Invariants of our Design (설계 불변 조건)**
### **✅ Invariant 1: Threshold-Based Row Swapping**
✔ 특정 Row가 임계값 **T** 이상 활성화될 경우, **RRS는 반드시 Row-Swap을 수행해야 함.**  
✔ **즉, 공격자가 특정 행을 Hammering하면, 해당 행은 반드시 Swap되므로 공격이 지속될 수 없음.**  
✔ 이를 통해 공격자가 특정 행을 계속해서 Hammering하여 Bit-Flip을 유발하는 것을 방지할 수 있음.

**📌 Invariant 1의 증명:**  
- Hot-Row Tracker가 특정 Row가 **T** 이상의 활성화 횟수를 기록하면, 해당 Row는 무작위(Random)로 다른 Row와 Swap됨.  
- 공격자가 특정 행을 지속적으로 Hammering할 경우, 해당 Row는 반복적으로 Swap되므로 공격자의 타겟팅이 어려워짐.  
- **결과적으로, 특정 Row를 반복적으로 Hammering하여 비트 플립을 유발하는 것이 불가능해짐.**

---

### **✅ Invariant 2: Row Swapping with Random Destination**
✔ 특정 행(Row)이 Swap될 때, **Swap 대상 행(Destination Row)은 공격자가 예측할 수 없어야 함.**  
✔ 즉, 공격자가 특정 Row를 Hammering하여 Swap을 유도할 수는 있지만, **그 행이 어디로 이동하는지는 예측할 수 없어야 함.**  

**📌 Invariant 2의 증명:**  
- RRS는 특정 행이 Swap될 때, **Swap 대상 행을 무작위(Random)로 선택함.**  
- 공격자가 특정 Row를 Hammering하더라도, 해당 Row가 어디로 이동하는지는 예측할 수 없음.  
- 따라서 공격자가 특정한 Victim Row를 선택적으로 공격하는 것이 불가능해짐.

📌 **즉, 공격자가 특정한 Row를 반복적으로 Hammering하더라도, Swap이 랜덤하게 이루어지기 때문에 공격자의 예측 가능성이 차단됨.**

---

## **📌 5.3 Row Hammer Prevention with RRS (RRS의 Row Hammer 방어)**
### **✅ Row Hammer 공격 모델**
✔ Row Hammer 공격은 공격자가 **Aggressor Row를 반복적으로 활성화(Activate)하여, 인접한 Victim Row에서 비트 플립(Bit-Flip)을 유발하는 공격**임.  
✔ 기존의 방어 기법들은 **Victim Row를 Refresh하는 방식(VFM) 또는 ECC를 활용하는 방식(ECC-Based Defense)**을 사용하지만, RRS는 **Aggressor Row 자체를 변경(Swap)하는 방식**을 사용함.

### **✅ RRS의 Row Hammer 방어 방식**
✔ RRS는 특정 Row가 일정 횟수 이상 활성화되면, **그 Row를 무작위(Random)로 다른 Row와 Swap함.**  
✔ 공격자는 특정한 Row를 Hammering할 수는 있지만, **그 Row가 지속적으로 존재하는 것이 아니라 Swap되므로 공격이 불가능해짐.**  
✔ **따라서 공격자는 특정한 Victim Row를 찾아내는 것이 불가능해짐.**  

📌 **즉, RRS는 공격자의 타겟을 무작위로 변경함으로써 Row Hammer 공격을 원천적으로 차단함.**

---

## **📌 5.4 Security of Row Swap Structures (Row Swap 구조의 보안성)**
### **✅ RRS의 보안성을 위협할 수 있는 요소**
✔ **Swap 과정에서 공격자가 특정한 패턴을 발견할 가능성이 있음.**  
✔ 공격자가 Swap이 발생하는 방식이나 Swap 이후의 Row Mapping을 추론할 수 있다면, **Row Hammer 공격을 변형하여 우회할 가능성이 있음.**  

### **✅ RRS의 보안 강화 방법**
1️⃣ **Swap이 발생하는 시점과 Swap 대상 행을 완전히 무작위(Random)로 설정**  
2️⃣ **Row Indirection Table(RIT)을 효율적으로 관리하여 공격자가 Swap 패턴을 추론할 수 없도록 함.**  
3️⃣ **Hot-Row Tracker의 감지 기준을 Adaptive하게 조정하여, 공격자가 특정 Swap 임계값을 예측할 수 없도록 함.**

📌 **즉, Swap 패턴을 예측할 수 없도록 설계하면, 공격자가 Row Hammer 공격을 변형하여 우회하는 것이 불가능해짐.**

---

## **📌 5.5 Latency Implications of RIT Lookups and Installs (RIT 조회 및 설치의 지연시간)**
### **✅ RIT 조회 및 설치 과정**
✔ RIT는 특정 Row가 Swap될 경우, 원래의 주소와 새로운 주소 간의 매핑 정보를 저장하는 데이터 구조임.  
✔ 공격자가 Swap된 행을 추적하지 못하도록, **RIT 조회 연산이 일정한 지연 시간(Constant Latency)을 가지도록 설계됨.**  

### **✅ 보안적 고려사항**
✔ 공격자가 Swap 후의 Row 위치를 예측하지 못하도록, **RIT 조회 속도를 일정하게 유지하여 Timing Side-Channel Attack을 방지함.**  
✔ **즉, RRS는 공격자가 특정 Swap 패턴을 감지할 수 없도록 RIT 조회 및 설치 과정을 최적화함.**

📌 **즉, RIT 조회 속도를 일정하게 유지하여, 공격자가 Swap 패턴을 분석할 수 없도록 설계됨.**

---

## **📌 5.6 Summary of Security Analysis (보안 분석 요약)**
✔ RRS는 **Row Hammer 공격을 효과적으로 방어할 수 있도록 설계됨.**  
✔ **Hot-Row Tracker를 활용하여 특정 행이 과도하게 활성화되는지 감지하고, 필요할 때 Swap을 수행함.**  
✔ **Row Indirection Table (RIT)을 사용하여 Swap 이후에도 메모리 접근을 원활하게 유지할 수 있음.**  
✔ **Swap이 발생하는 시점과 Swap 대상 행을 랜덤하게 선택하여 공격자가 Swap 패턴을 예측하지 못하도록 설계됨.**  
✔ **Swap이 발생하더라도, RIT 조회 속도를 일정하게 유지하여 Side-Channel Attack을 방지할 수 있음.**  

📌 **즉, RRS는 공격자가 특정한 Row를 지속적으로 Hammering하여 Bit-Flip을 유발하는 것을 원천적으로 차단하는 강력한 방어 기법임.** 🚀

---

# **6. Architecting Scalable Structures (확장 가능한 구조 설계)**

## **📌 6.1 Collision Avoidance Table (CAT)**
### **✅ 개요**
✔ **Collision Avoidance Table (CAT)**은 **RRS의 확장성을 높이기 위한 데이터 구조**로,  
✔ 기존 **Set-Associative 방식과 여러 개의 무작위 해시(Randomized Hashing) 기법을 결합하여 충돌을 방지하도록 설계됨.**  

### **✅ CAT의 주요 설계 요소**
✔ **Set-Associative 구조**:  
   - **CAT은 T1과 T2라는 두 개의 테이블을 유지하며, 각각 독립적인 해시 함수(H1, H2)를 사용하여 데이터를 저장**  
   - **즉, 동일한 Row가 두 개의 서로 다른 해시 값에 따라 두 개의 위치(T1과 T2) 중 하나에 저장됨.**  

✔ **충돌 방지를 위한 Over-Provisioning**:  
   - **테이블은 "D demand ways" + "E extra ways"의 형태로 구성되며, "E extra ways"를 추가하여 충돌을 피할 확률을 높임.**  
   - **D = C / 2S의 관계식을 적용하여 테이블이 충분히 Over-Provisioning되도록 설계.**  

✔ **삽입(Install) 과정에서 충돌이 발생할 경우, 가장 적은 유효 엔트리를 가진 Set을 선택하여 데이터 저장**  
   - **이 방식을 통해, 특정 Set이 과부하되는 문제를 방지하고 균형 있게 Row를 배분할 수 있음.**  

📌 **즉, CAT은 Randomized Hashing과 Over-Provisioning을 조합하여 충돌을 최소화하고, RRS의 확장성을 보장하는 데이터 구조임.**

---

## **📌 6.2 Setting Bounds on Conflict with CAT**
### **✅ CAT의 충돌 가능성 분석**
✔ **CAT에서 충돌이 발생하는 경우는 다음과 같은 상황에서 발생함.**  
✔ **즉, 동일한 Row가 두 개의 테이블(T1, T2)에서 모두 충돌이 발생하는 경우**  
✔ 따라서, 논문에서는 **Monte Carlo 시뮬레이션 및 이론적 분석을 통해 충돌 확률을 분석**  

### **✅ CAT의 충돌 확률 및 수학적 모델**
✔ 논문에서는 **MIRAGE 모델을 사용하여 충돌 확률을 정량적으로 분석**  
✔ **Monte Carlo Simulation**을 통해 1~4 Extra Ways를 설정한 경우의 충돌 확률을 계산  
✔ 5~6 Extra Ways의 경우 **MIRAGE 모델 기반으로 충돌 확률이 10^30 이상의 Install 이후에 발생**  

📌 **즉, 충분한 Over-Provisioning을 적용하면, CAT은 사실상 충돌이 거의 발생하지 않는 구조를 가질 수 있음.**

---

## **📌 6.3 Designing Scalable RIT with CAT**
### **✅ RIT의 확장성 문제 해결**
✔ 기존 RIT는 **3400개의 Tuple을 저장해야 하며, 이는 약 6800개의 엔트리를 필요로 함.**  
✔ 이를 CAT을 이용하여 **효율적으로 저장할 수 있도록 확장성 있는 설계를 적용**  
✔ **각 엔트리는 "Source Row-ID", "Destination Row-ID", "Lock Bit"을 저장하며, 추가적인 오버헤드를 최소화하도록 설계됨.**  
✔ **Eviction 정책을 적용하여, 필요할 때만 Entry를 삭제하여 효율성을 유지함.**

📌 **즉, CAT을 활용하여 RIT의 저장 공간을 최적화하고, 대규모 시스템에서도 RRS를 효율적으로 적용할 수 있도록 설계됨.**

---

## **📌 6.4 Designing Scalable Tracker with CAT**
### **✅ Misra-Gries 알고리즘을 활용한 Tracker 설계**
✔ Misra-Gries 알고리즘을 활용하여 **효율적으로 Hot-Row를 감지하는 Tracker를 설계**  
✔ 기존의 Fully Associative 구조보다 더 효율적으로 **Row-ID 및 Access Counter를 저장할 수 있도록 설계됨.**  
✔ **SetMin Counter**를 추가하여 **최소 접근 횟수를 빠르게 계산할 수 있도록 최적화**  

📌 **즉, 기존 Tracker 구조를 개선하여, 오버헤드를 줄이면서도 정확도를 유지할 수 있도록 Misra-Gries 알고리즘을 적용함.**

---

## **📌 6.5 Summary of Scalability Enhancements**
✔ **Collision Avoidance Table (CAT)을 활용하여 RRS의 확장성을 향상**  
✔ **충돌이 거의 발생하지 않도록 Over-Provisioning 기법 적용**  
✔ **Scalable RIT와 Tracker를 설계하여, 대규모 시스템에서도 RRS 적용 가능**  
✔ **Misra-Gries 알고리즘을 활용하여, Hot-Row Tracker의 성능을 최적화**  

📌 **즉, RRS는 CAT을 기반으로 확장 가능한 구조를 설계하여, 대규모 DRAM에서도 성능 저하 없이 적용 가능하도록 개선됨.** 🚀

---
# **7. Results and Analysis (결과 및 분석)**

## **📌 7.1 Storage Analysis (저장 공간 분석)**
### **✅ RRS의 저장 공간 요구량**
✔ RRS는 **Hot-Row Tracker, Row Indirection Table (RIT), Swap Buffers**와 같은 추가적인 구조를 필요로 함.  
✔ 따라서, DRAM 내에서 **추가적인 저장 공간(Storage Overhead)이 발생할 수 있음.**  

### **✅ Table 5: Storage Overhead Per Bank**
| **구성 요소** | **비트(bit) 단위 크기** | **Entry 개수** | **총 크기** |
|-------------|------------------|-------------|-------------|
| **RIT (Row Indirection Table)** | 28 bits | 256 × 20 | **35 KB** |
| **Tracker (Hot-Row Tracker)** | 22 bits | 256 × 20 | **30 KB** |
| **Swap Buffers** | - | - | **16 KB** |
| **총 저장 공간** | - | - | **42.9 KB per Bank** |
| **총 오버헤드 (per Rank)** | - | - | **686 KB per Rank** |

📌 **즉, RRS는 Bank당 약 42.9KB, Rank당 약 686KB의 추가적인 저장 공간이 필요함.**  
📌 **이는 기존 DRAM 아키텍처에서 비교적 작은 오버헤드로 적용할 수 있음을 의미함.**  

---

## **📌 7.2 Power Analysis (전력 소모 분석)**
### **✅ RRS의 전력 소비 특성**
✔ RRS는 **추가적인 Row-Swap 연산 및 SRAM 기반 구조(RIT, Tracker 등)로 인해 전력 소모가 증가할 가능성이 있음.**  
✔ 하지만, 전력 소모가 기존 Row Hammer 방어 기법에 비해 상대적으로 낮은 수준으로 유지됨.  

### **✅ Table 6: Extra Power Consumption in RRS Per Rank**
| **구성 요소** | **추가 전력 소모** |
|-------------|------------------|
| **DRAM Power Overhead (Row-Swap 연산으로 인한 추가 소모)** | **+0.5%** |
| **SRAM Power Overhead (RIT, Tracker 등으로 인한 추가 소모)** | **903 mW per Rank** |

📌 **즉, RRS는 전체 DRAM 전력 소비를 약 0.5% 증가시키며, RIT 및 Tracker 등의 구조로 인해 랭크당 약 903mW의 추가 전력 소비가 발생함.**  
📌 **하지만, 이는 최신 DRAM 기술을 사용할 경우 최적화될 가능성이 높음.**  

---

## **📌 7.3 Performance Sensitivity to RH-Threshold (Row Hammer 임계값에 따른 성능 민감도 분석)**
### **✅ Row Hammer 임계값(τRH)의 변화에 따른 성능 영향**
✔ RRS의 성능은 **Row Hammer Threshold (τRH)가 어떻게 설정되느냐에 따라 영향을 받을 수 있음.**  
✔ τRH 값이 낮을수록 Swap이 자주 발생하여 성능이 저하될 가능성이 있음.  

### **✅ Figure 10: Performance of RRS across RH-Threshold**
- **X축:** 다양한 벤치마크 실행 결과  
- **Y축:** 정규화된 성능(Normalized Performance), 값이 1.0이면 성능 저하 없음.  
- **Row Hammer Threshold(τRH) 값 변경에 따른 성능 변화 분석.**  

### **✅ 실험 결과 요약**
| **τRH 값** | **평균 성능 저하** |
|-------------|------------------|
| **τRH = 2.4K (0.5× 기본값)** | **4.5% 성능 저하** |
| **τRH = 3.2K (0.67× 기본값)** | **2.2% 성능 저하** |
| **τRH = 4.8K (기본값)** | **0.4% 성능 저하** |
| **τRH = 9.6K (2× 기본값)** | **사실상 성능 저하 없음** |

📌 **즉, τRH 값이 낮아질수록 Swap이 자주 발생하여 성능 저하가 발생하지만, 기본값(4.8K) 이상에서는 성능 영향이 미미함.**  

---

## **📌 7.4 RRS vs. BlockHammer**
### **✅ BlockHammer와의 성능 비교**
✔ 기존 Row Hammer 방어 기법 중 하나인 **BlockHammer**와 RRS를 비교 분석함.  
✔ BlockHammer는 **Counting Bloom Filter를 사용하여 공격 행을 감지하고, 활성화를 지연(Delay)시키는 방식**을 사용함.  
✔ 하지만, BlockHammer는 성능 오버헤드가 더 크고, 서비스 거부(Denial of Service, DoS) 문제를 유발할 가능성이 있음.  

### **✅ Figure 11: Performance S-Curve for RRS and BlockHammer**
| **방어 기법** | **최악의 경우 성능 저하** | **평균 성능 저하** |
|-------------|------------------|------------------|
| **BlockHammer (Blacklisting Threshold = 512, 1K)** | **최대 21.7% 성능 저하** | **평균 2% 성능 저하** |
| **RRS (Randomized Row-Swap)** | **최대 7.6% 성능 저하** | **평균 0.4% 성능 저하** |

📌 **즉, BlockHammer는 일부 애플리케이션에서 21.7%까지 성능 저하가 발생할 수 있는 반면, RRS는 평균적으로 0.4%의 성능 저하만 발생함.**  
📌 **따라서, RRS는 성능 측면에서도 실용적인 방어 기법으로 적용 가능함.**  

---

## **📌 7.5 Summary of Results and Analysis**
✔ **Storage Analysis:** RRS는 Bank당 약 42.9KB, Rank당 약 686KB의 추가 저장 공간을 요구하지만, 기존 DRAM 아키텍처와 비교하면 적은 오버헤드를 가짐.  
✔ **Power Analysis:** DRAM 전력 소비가 0.5% 증가하며, RRS 구조로 인해 랭크당 903mW의 추가 전력 소모가 발생하지만, 최적화 가능성이 높음.  
✔ **Performance Sensitivity:** Row Hammer Threshold(τRH)가 낮을 경우 성능 저하가 발생하지만, 기본값(4.8K) 이상에서는 성능 영향이 미미함.  
✔ **RRS vs. BlockHammer:** BlockHammer는 일부 애플리케이션에서 21.7%까지 성능 저하가 발생하는 반면, RRS는 평균 0.4%의 성능 저하만 발생하여 더 실용적임.  

📌 **즉, RRS는 기존의 Row Hammer 방어 기법보다 저장 공간, 전력 소비, 성능 저하 측면에서 더 효율적이며, 실용적인 방어 기법으로 적용 가능함.** 🚀
